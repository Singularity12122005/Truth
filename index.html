<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>四色定理：演绎迷踪 (Q.E.D. Project)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --c1: #ef4444;
      --c2: #3b82f6;
      --c3: #22c55e;
      --c4: #eab308;
      --c-uncolored: #9ca3af;
      --c-uncolored-bg: #f3f4f6;
    }
    body { font-family: 'Noto Sans SC', sans-serif; overscroll-behavior: none; }
    .graph-canvas { touch-action: none; cursor: grab; }
    .vertex { transition: all .3s ease; cursor: pointer; }
    .vertex:hover { transform: scale(1.2); filter: brightness(1.1); }
    .vertex.selected {
      stroke: #a855f7; stroke-width: 6px;
      filter: drop-shadow(0 0 8px #a855f7);
    }
    .edge { transition: all .3s ease; stroke: #4b5563; stroke-width: 3; }
    .edge.conflict {
      stroke: #f43f5e; stroke-width: 5px;
      animation: pulse 1s infinite;
    }
    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:.5} }
    .kempe-chain { animation: kempe-flow 2s linear infinite; }
    @keyframes kempe-flow { from{stroke-dashoffset:20}to{stroke-dashoffset:0} }
    .trace-step { transition: background-color .3s; }
    .trace-step.dep-source { animation: dep-pulse-source 1.5s infinite; }
    .trace-step.dep-blocked { animation: dep-pulse-blocked 1.5s infinite; }
    @keyframes dep-pulse-source {
      0%,100%{background-color:rgba(34,197,94,0.3)}
      50%{background-color:rgba(34,197,94,0.1)}
    }
    @keyframes dep-pulse-blocked {
      0%,100%{background-color:rgba(239,68,68,0.3)}
      50%{background-color:rgba(239,68,68,0.1)}
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col h-screen overflow-hidden">

  <!-- Header -->
  <header class="bg-gray-800/50 backdrop-blur-sm p-3 flex justify-between items-center shadow-lg z-10">
    <div>
      <h1 class="text-xl font-bold">四色定理：演绎迷踪</h1>
      <p class="text-sm text-gray-400">Project Q.E.D. – An Interactive Formal Proof</p>
    </div>
    <div id="level-selector" class="flex items-center gap-2">
      <span class="text-gray-400">关卡:</span>
    </div>
  </header>

  <!-- Main -->
  <main class="flex-1 flex overflow-hidden">

    <!-- 左侧面板 -->
    <aside class="w-1/3 max-w-md bg-gray-800/30 p-4 flex flex-col space-y-4 overflow-y-auto">
      <!-- 算子面板 -->
      <section>
        <h2 class="text-lg font-semibold mb-2 border-b-2 border-gray-700 pb-1">算子面板 (Operators)</h2>
        <div id="operator-panel" class="grid grid-cols-2 gap-2">
          <!-- 调色板 -->
          <div id="color-palette" class="col-span-2 grid grid-cols-4 gap-2">
            <button data-color="c1" class="p-4 rounded-lg bg-red-500 hover:bg-red-600 disabled:bg-gray-600"></button>
            <button data-color="c2" class="p-4 rounded-lg bg-blue-500 hover:bg-blue-600 disabled:bg-gray-600"></button>
            <button data-color="c3" class="p-4 rounded-lg bg-green-500 hover:bg-green-600 disabled:bg-gray-600"></button>
            <button data-color="c4" class="p-4 rounded-lg bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-600"></button>
          </div>
          <button id="op-cut"    class="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg disabled:bg-gray-600">Cut(v)</button>
          <button id="op-return" class="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg disabled:bg-gray-600">Return</button>
          <button id="op-invert" class="p-2 bg-teal-600 hover:bg-teal-700 rounded-lg disabled:bg-gray-600">Invert(K)</button>
          <button id="op-undo"   class="p-2 bg-gray-500 hover:bg-gray-600 rounded-lg disabled:bg-gray-600">Undo</button>
        </div>
        <!-- Invert 细节 -->
        <div id="invert-panel" class="hidden mt-4 p-3 bg-gray-700/50 rounded-lg">
          <h3 class="text-md font-medium mb-2">选择 Kempe 链颜色对:</h3>
          <div id="invert-color-selector" class="grid grid-cols-4 gap-2"></div>
          <button id="invert-confirm" class="w-full mt-2 p-2 bg-teal-500 hover:bg-teal-600 rounded-lg disabled:bg-gray-600">确认交换</button>
          <button id="invert-cancel"  class="w-full mt-2 p-2 bg-gray-500 hover:bg-gray-600 rounded-lg">取消</button>
        </div>
        <!-- Report 面板 -->
        <div id="report-panel" class="hidden mt-4 p-3 bg-rose-900/50 rounded-lg">
          <h3 class="text-md font-medium mb-2 text-rose-300">分析报告：依赖性冲突</h3>
          <p id="report-text" class="text-sm mb-3"></p>
          <button id="report-submit" class="w-full p-2 bg-rose-600 hover:bg-rose-700 rounded-lg">提交报告，确认理解</button>
        </div>
      </section>

      <!-- 归纳栈 -->
      <section>
        <h2 class="text-lg font-semibold mb-2 border-b-2 border-gray-700 pb-1">归纳栈 (Stack)</h2>
        <div id="induction-stack" class="bg-gray-900/50 p-2 rounded-lg min-h-[50px] text-center text-gray-500">空</div>
      </section>

      <!-- 证明轨迹 -->
      <section class="flex-1 flex flex-col">
        <h2 class="text-lg font-semibold mb-2 border-b-2 border-gray-700 pb-1">证明轨迹 (Proof Trace)</h2>
        <div id="proof-trace" class="flex-1 bg-gray-900/50 p-2 rounded-lg overflow-y-auto space-y-1">
          <!-- JS 注入 -->
        </div>
      </section>
    </aside>

    <!-- 右侧画布 -->
    <div class="flex-1 flex flex-col p-4">
      <div id="info-bar" class="mb-4 p-3 bg-gray-800/50 rounded-lg shadow-md text-center">
        <p id="info-text" class="text-lg text-gray-300">选择一个顶点再执行操作。</p>
      </div>
      <div class="flex-1 bg-gray-800 rounded-lg shadow-inner overflow-hidden relative">
        <svg id="graph-canvas" class="w-full h-full graph-canvas"></svg>
        <div id="modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50">
          <div class="bg-gray-800 p-8 rounded-xl shadow-2xl max-w-lg text-center border-2 border-purple-500">
            <h2 id="modal-title" class="text-2xl font-bold mb-4"></h2>
            <p id="modal-body" class="mb-6"></p>
            <button id="modal-close" class="px-6 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg">继续</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- 完整 JS（M0–M8）-->
  <script type="module">
  // --- M0 Utils ---
  const UNCOLORED = null;
  function deepClone(obj) {
    if (obj===null||typeof obj!=='object') return obj;
    if (obj instanceof Map) {
      const m=new Map();
      for(const [k,v] of obj.entries()) m.set(k,deepClone(v));
      return m;
    }
    if (obj instanceof Set) {
      const s=new Set();
      for(const v of obj) s.add(deepClone(v));
      return s;
    }
    if (Array.isArray(obj)) return obj.map(deepClone);
    if (obj instanceof Date) return new Date(obj.getTime());
    const out={};
    for(const [k,v] of Object.entries(obj)) out[k]=deepClone(v);
    return out;
  }
  function stableHash(obj) {
    const str = JSON.stringify(obj, (k,v)=>{
      if (v instanceof Map) return {__type:'Map', value:Array.from(v).sort()};
      if (v instanceof Set) return {__type:'Set', value:Array.from(v).sort()};
      return v;
    });
    let h=0;
    for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; }
    return (h>>>0).toString(16).padStart(8,'0');
  }

  // --- M1 Graph ---
  class Graph {
    constructor(){
      this.V=new Set();
      this.E=new Set();
      this.adj=new Map();
      this.rotation=new Map();
      this.positions=new Map();
    }
    addVertex(v, rotList=[], pos={x:0,y:0}) {
      if(this.V.has(v)) throw new Error(`Vertex ${v} exists`);
      this.V.add(v);
      this.adj.set(v,new Set());
      this.rotation.set(v,Array.from(rotList));
      this.positions.set(v,{x:pos.x,y:pos.y});
    }
    addEdge(u,v) {
      if(u===v) throw new Error(`Self-loop at ${u}`);
      if(!this.V.has(u)||!this.V.has(v)) throw new Error(`Missing endpoint`);
      const [a,b]=u<v?[u,v]:[v,u], key=`${a}-${b}`;
      if(this.E.has(key)) throw new Error(`Parallel edge ${key}`);
      this.E.add(key);
      this.adj.get(u).add(v);
      this.adj.get(v).add(u);
      this.rotation.get(u).push(v);
      this.rotation.get(v).push(u);
    }
    removeVertex(v){
      if(!this.V.has(v)) throw new Error(`No ${v}`);
      const neighbors=Array.from(this.adj.get(v));
      const rot=Array.from(this.rotation.get(v));
      const pos={...this.positions.get(v)};
      for(const u of neighbors){
        this.adj.get(u).delete(v);
        const [a,b]=u<v?[u,v]:[v,u];
        this.E.delete(`${a}-${b}`);
        this.rotation.set(u,this.rotation.get(u).filter(x=>x!==v));
      }
      this.V.delete(v);
      this.adj.delete(v);
      this.rotation.delete(v);
      this.positions.delete(v);
      return {v,neighbors,rot,pos};
    }
    neighbors(v){
      if(!this.V.has(v)) throw new Error(`No ${v}`);
      return Array.from(this.adj.get(v));
    }
    clone(){
      const g2=new Graph();
      for(const v of this.V){
        g2.V.add(v);
        g2.adj.set(v,new Set(this.adj.get(v)));
        g2.rotation.set(v,Array.from(this.rotation.get(v)));
        g2.positions.set(v,{...this.positions.get(v)});
      }
      for(const e of this.E) g2.E.add(e);
      return g2;
    }
    isPlanar(){ return true; /* TODO: embed Boyer–Myrvold */ }
    static fromData(data){
      const g=new Graph();
      for(const v of data.vertices) g.addVertex(v.id,v.rot||[],v.pos);
      for(const [u,v] of data.edges) g.addEdge(u,v);
      if(!g.isPlanar()) throw new Error("Not planar");
      return g;
    }
  }

  // --- M2 State & Predicates ---
  class GameState {
    constructor(graph,phi){
      this.graph=graph;
      this.phi=phi;
      this.hash=stableHash({adj:graph.adj,phi});
    }
    clone(){
      return new GameState(this.graph.clone(),deepClone(this.phi));
    }
  }
  const Predicates={
    isProper(s){
      for(const e of s.graph.E){
        const [u,v]=e.split('-');
        const cu=s.phi.get(u), cv=s.phi.get(v);
        if(cu!==UNCOLORED && cu===cv) return false;
      }
      return true;
    },
    isFullyColored(s){
      for(const v of s.graph.V) if(s.phi.get(v)===UNCOLORED) return false;
      return true;
    },
    isWinning(s){ return this.isProper(s)&&this.isFullyColored(s); }
  };
  const Kempe={
    computeChain(s,root,a,b){
      if(!s.graph.V.has(root)) return [];
      const q=[root], vis=new Set([root]), chain=[];
      const pick=new Set([a,b]);
      while(q.length){
        const u=q.shift(); chain.push(u);
        for(const w of s.graph.neighbors(u)){
          if(!vis.has(w) && pick.has(s.phi.get(w))){
            vis.add(w); q.push(w);
          }
        }
      }
      return chain.sort((x,y)=>String(x).localeCompare(y));
    },
    checkDependency(s,op1,op2){
      const before=this.computeChain(s,op2.args.root,op2.args.a,op2.args.b);
      const after=this.computeChain(op1.execute(s.clone()),op2.args.root,op2.args.a,op2.args.b);
      return stableHash(before)!==stableHash(after); // ≤ syntax is correct: !==
    }
  };

  // --- M3 Operators ---
  class Operator{ constructor(name,args){this.op=name;this.args=args;} }
  class AssignOp extends Operator{
    constructor(v,c){super('Assign',{v,c});}
    execute(s){const t=s.clone();t.phi.set(this.args.v,this.args.c);return t;}
    domain(){return new Set([this.args.v]);}
  }
  class CutOp extends Operator{
    constructor(v){super('Cut',{v});}
    execute(s){const t=s.clone();const mem=t.graph.removeVertex(this.args.v);mem.phi_v=s.phi.get(this.args.v);t.phi.delete(this.args.v);Game.inductionStack.push(mem);return t;}
    domain(){return new Set([this.args.v]);}
  }
  class ReturnOp extends Operator{
    constructor(){super('Return',{});}
    execute(s){if(!Game.inductionStack.length) return s;const t=s.clone();const mem=Game.inductionStack.pop();t.graph.addVertex(mem.v,mem.rot,mem.pos);for(const u of mem.neighbors)t.graph.addEdge(mem.v,u);t.phi.set(mem.v,UNCOLORED);return t;}
    domain(){const top=Game.inductionStack[Game.inductionStack.length-1];return top?new Set([top.v]):new Set();}
  }
  class InvertOp extends Operator{
    constructor(root,a,b){super('Invert',{root,a,b});}
    computeDomain(s){return new Set(Kempe.computeChain(s,this.args.root,this.args.a,this.args.b));}
    execute(s){const t=s.clone();const chain=Kempe.computeChain(t,this.args.root,this.args.a,this.args.b);for(const v of chain){if(t.phi.get(v)===this.args.a) t.phi.set(v,this.args.b); else if(t.phi.get(v)===this.args.b) t.phi.set(v,this.args.a);}return t;}
  }

  // --- M4 TraceManager ---
  class TraceManager{
    constructor(){this.trace=[];}
    addStep(op,oldS,newS,extra={}){const dom=op.domain? (typeof op.domain==='function'?op.domain(oldS):op.domain): (op.computeDomain?op.computeDomain(oldS):new Set());this.trace.push({idx:this.trace.length,op:op.op,args:deepClone(op.args),pre_hash:oldS.hash,post_hash:newS.hash,domain:dom,legal:true,...extra});}
    addAttempt(op,by){this.trace.push({idx:this.trace.length,op:`Attempt${op.op}`,args:deepClone(op.args),blocked_by:by,state_unchanged:true,legal:false,domain:new Set()});}
    undo(){
      if(!this.trace.length) return null;
      this.trace.pop();
      Game.inductionStack=[];
      let s=LevelManager.getInitialState(Game.currentLevelId);
      for(const step of this.trace){
        const C={Assign:AssignOp,Cut:CutOp,Return:ReturnOp,Invert:InvertOp}[step.op];
        if(C&&step.legal){s=new C(...Object.values(step.args)).execute(s);}
      }
      return s;
    }
    getCanonicalTrace(){return this.trace;}
  }

  // --- M5 GoalChecker ---
  const GoalChecker={
    predicates:{
      win_by_coloring:(S,T)=>Predicates.isWinning(S),
      win_by_induction:(S,T)=>Predicates.isWinning(S)&&T.some(t=>t.op==='Cut')&&T.some(t=>t.op==='Return'),
      win_by_kempe:(S,T)=>Predicates.isWinning(S)&&T.some(t=>t.op==='Invert'),
      win_by_dependency:(S,T)=>T.some(t=>t.op==='SubmitReport')
    },
    check(lv,S,T){if(this.predicates[LevelManager.levels[lv].goal]?.(S,T)) UI.showModal(`关卡 ${lv} 完成!`,LevelManager.levels[lv].winMessage);}
  };

  // --- M6 LevelManager ---
  const LevelManager={
    levels:{
      L0:{name:"L0: 基础着色", goal:"win_by_coloring", winMessage:"…", data:{vertices:[{id:0,pos:{x:20,y:50}},{id:1,pos:{x:50,y:50}},{id:2,pos:{x:80,y:50}}], edges:[[0,1],[1,2]]}},
      L1:{name:"L1: 归纳法",       goal:"win_by_induction", winMessage:"…", data:{vertices:[{id:0,pos:{x:25,y:25}},{id:1,pos:{x:75,y:25}},{id:2,pos:{x:75,y:75}},{id:3,pos:{x:25,y:75}},{id:4,pos:{x:50,y:50}}], edges:[[0,1],[1,2],[2,3],[3,0],[0,4],[1,4],[2,4],[3,4]]}},
      L2:{name:"L2: Kempe 链",     goal:"win_by_kempe",     winMessage:"…", data:{vertices:[{id:0,pos:{x:50,y:10}},{id:1,pos:{x:90,y:50}},{id:2,pos:{x:50,y:90}},{id:3,pos:{x:10,y:50}},{id:4,pos:{x:50,y:50}},{id:5,pos:{x:30,y:10}},{id:6,pos:{x:70,y:10}}], edges:[[0,4],[1,4],[2,4],[3,4],[0,5],[0,6],[5,6]]}},
      L4_BOSS:{name:"L4: 依赖性危机",goal:"win_by_dependency",winMessage:"…",data:{vertices:[{id:0,pos:{x:50,y:5}},{id:1,pos:{x:20,y:25}},{id:2,pos:{x:80,y:25}},{id:3,pos:{x:50,y:40}},{id:4,pos:{x:20,y:65}},{id:5,pos:{x:80,y:65}},{id:6,pos:{x:50,y:80}},{id:7,pos:{x:50,y:95}}], edges:[[0,1],[0,2],[1,3],[2,3],[1,4],[3,4],[3,5],[2,5],[4,6],[5,6],[6,7]]}}
    },
    initialStates:new Map(),
    init(){
      for(const [id,lvl] of Object.entries(this.levels)){
        const g=Graph.fromData(lvl.data);
        const phi=new Map();
        for(const v of g.V) phi.set(v,UNCOLORED);
        if(id==='L2'){
          phi.set(0,'c1');phi.set(1,'c2');phi.set(2,'c3');phi.set(3,'c4');phi.set(5,'c2');phi.set(6,'c3');
        }
        if(id==='L4_BOSS'){
          phi.set(0,'c1');phi.set(7,'c1');phi.set(1,'c2');phi.set(2,'c3');phi.set(4,'c3');phi.set(5,'c2');phi.set(6,'c4');
        }
        this.initialStates.set(id,new GameState(g,phi));
      }
    },
    getInitialState(id){ return this.initialStates.get(id).clone(); }
  };

  // --- M7 UIManager ---
  let UI;
  class UIManager {
    constructor(){
      this.svg=document.getElementById('graph-canvas');
      this.infoText=document.getElementById('info-text');
      this.opPanel=document.getElementById('operator-panel');
      this.tracePanel=document.getElementById('proof-trace');
      this.stackPanel=document.getElementById('induction-stack');
      this.invertPanel=document.getElementById('invert-panel');
      this.reportPanel=document.getElementById('report-panel');
      this.modal=document.getElementById('modal');
      this.modalTitle=document.getElementById('modal-title');
      this.modalBody=document.getElementById('modal-body');
      this.vb={x:0,y:0,w:100,h:100};
      this.isPanning=false;
      this.startPt={x:0,y:0};
    }
    init(){
      UI=this;
      // 关卡按钮
      const sel=document.getElementById('level-selector');
      for(const id of Object.keys(LevelManager.levels)){
        const btn=document.createElement('button');
        btn.textContent=id;
        btn.className='px-3 py-1 rounded-md bg-gray-700 hover:bg-purple-600';
        btn.onclick=()=>Game.loadLevel(id);
        sel.appendChild(btn);
      }
      // 画布交互
      this.svg.addEventListener('wheel',this.onZoom.bind(this),{passive:false});
      this.svg.addEventListener('pointerdown',this.onPointerDown.bind(this));
      this.svg.addEventListener('pointerup',this.onPointerUp.bind(this));
      this.svg.addEventListener('pointerleave',this.onPointerUp.bind(this));
      this.svg.addEventListener('pointermove',this.onPointerMove.bind(this));
      // 算子绑定
      document.getElementById('op-cut').onclick=()=>Game.handleOperator('Cut');
      document.getElementById('op-return').onclick=()=>Game.handleOperator('Return');
      document.getElementById('op-invert').onclick=()=>this.showInvertPanel();
      document.getElementById('op-undo').onclick=()=>Game.handleOperator('Undo');
      document.getElementById('invert-cancel').onclick=()=>this.hideInvertPanel();
      document.getElementById('invert-confirm').onclick=()=>{
        const sel=this.invertPanel.querySelector('input[name="color-pair"]:checked');
        if(sel){
          const [a,b]=sel.value.split(',');
          Game.handleOperator('Invert',{a,b});
          this.hideInvertPanel();
        }
      };
      document.getElementById('report-submit').onclick=()=>{
        Game.handleOperator('SubmitReport');
        this.hideReportPanel();
      };
      document.getElementById('modal-close').onclick=()=>this.hideModal();
      // 调色板
      document.querySelectorAll('#color-palette button').forEach(btn=>{
        btn.onclick=()=>Game.handleOperator('Assign',{color:btn.dataset.color});
      });
    }
    render(s){
      this.renderGraph(s);
      this.renderTrace(Game.traceManager.trace);
      this.renderStack(Game.inductionStack);
      this.updateOperatorPanel(s);
    }
    renderGraph(s){
      const svg=this.svg; svg.innerHTML='';
      const g=s.graph;
      // 计算 viewBox
      const xs=Array.from(g.V).map(v=>g.positions.get(v).x);
      const ys=Array.from(g.V).map(v=>g.positions.get(v).y);
      const minX=Math.min(...xs), maxX=Math.max(...xs);
      const minY=Math.min(...ys), maxY=Math.max(...ys);
      const pad=20;
      this.vb.x=minX-pad; this.vb.y=minY-pad;
      this.vb.w=(maxX-minX)+2*pad; this.vb.h=(maxY-minY)+2*pad;
      svg.setAttribute('viewBox',`${this.vb.x} ${this.vb.y} ${this.vb.w} ${this.vb.h}`);
      // 边
      const eg=document.createElementNS('http://www.w3.org/2000/svg','g');
      for(const key of g.E){
        const [u,v]=key.split('-').map(Number);
        const pu=g.positions.get(u), pv=g.positions.get(v);
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
        ln.setAttribute('x1',pu.x); ln.setAttribute('y1',pu.y);
        ln.setAttribute('x2',pv.x); ln.setAttribute('y2',pv.y);
        ln.classList.add('edge');
        if(s.phi.get(u)!==UNCOLORED && s.phi.get(u)===s.phi.get(v)){
          ln.classList.add('conflict');
        }
        eg.appendChild(ln);
      }
      svg.appendChild(eg);
      // 顶点
      const vg=document.createElementNS('http://www.w3.org/2000/svg','g');
      for(const v of g.V){
        const pos=g.positions.get(v), col=s.phi.get(v);
        const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',pos.x); c.setAttribute('cy',pos.y); c.setAttribute('r',5);
        // —— 核心修复：用 style.fill/stroke 而非 fill 属性
        c.style.fill   = col? `var(--${col})` : `var(--c-uncolored-bg)`;
        c.style.stroke = col? 'none' : `var(--c-uncolored)`;
        c.style.strokeWidth = '1.5';
        c.dataset.id=v; c.classList.add('vertex');
        if(v===Game.selectedVertex) c.classList.add('selected');
        c.onclick=()=>Game.selectVertex(v);
        vg.appendChild(c);
        const t=document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x',pos.x); t.setAttribute('y',pos.y+1.5);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','4');
        t.textContent=v; t.style.fill=col?'white':'black';
        t.style.pointerEvents='none';
        vg.appendChild(t);
      }
      svg.appendChild(vg);
    }
    renderTrace(trace){
      this.tracePanel.innerHTML='';
      if(!trace.length){
        this.tracePanel.innerHTML='<p class="text-gray-500 text-center">轨迹为空</p>';
        return;
      }
      trace.forEach(st=>{
        const d=document.createElement('div');
        d.className='trace-step p-2 rounded-md bg-gray-800 text-sm';
        let txt=`<b>${st.idx}:</b> ${st.op}(${JSON.stringify(st.args)})`;
        if(st.dep_flag){
          d.classList.add('bg-rose-800/50','dep-blocked');
          txt+=` <span class="font-bold text-rose-400">[依赖于 #${st.blocked_by}]</span>`;
          const src=this.tracePanel.querySelector(`[data-idx="${st.blocked_by}"]`);
          if(src) src.classList.add('dep-source');
        }
        d.innerHTML=txt; d.dataset.idx=st.idx;
        this.tracePanel.appendChild(d);
      });
      this.tracePanel.scrollTop=this.tracePanel.scrollHeight;
    }
    renderStack(stack){
      this.stackPanel.innerHTML='';
      if(!stack.length){
        this.stackPanel.innerHTML='<p class="text-gray-500">空</p>'; return;
      }
      stack.forEach(mem=>{
        const d=document.createElement('div');
        d.className='p-1 bg-purple-900/50 rounded text-center';
        d.textContent=`M(${mem.v})`;
        this.stackPanel.prepend(d);
      });
    }
    updateOperatorPanel(s){
      const v=Game.selectedVertex, has= v!==null;
      const col= has? s.phi.get(v) : UNCOLORED;
      document.querySelectorAll('#color-palette button').forEach(b=>b.disabled=!has||col!==UNCOLORED);
      document.getElementById('op-cut').disabled = !has;
      document.getElementById('op-return').disabled = Game.inductionStack.length===0;
      document.getElementById('op-invert').disabled = !has||col===UNCOLORED;
      document.getElementById('op-undo').disabled = Game.traceManager.trace.length===0;
    }
    showInvertPanel(){
      if(Game.selectedVertex===null) return;
      const v=Game.selectedVertex;
      const neigh=Game.state.graph.neighbors(v);
      const nc=new Set(neigh.map(u=>Game.state.phi.get(u)).filter(c=>c!==UNCOLORED));
      const arr=Array.from(nc), pairs=[];
      for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) pairs.push([arr[i],arr[j]]);
      const selDiv=document.getElementById('invert-color-selector');
      selDiv.innerHTML='';
      document.getElementById('invert-confirm').disabled = pairs.length===0;
      if(!pairs.length){
        selDiv.innerHTML='<p class="text-sm text-gray-400 col-span-4">没有可用的颜色对。</p>';
      }
      pairs.forEach(([a,b],i)=>{
        const id=`pair-${i}`;
        const d=document.createElement('div');
        d.className='col-span-2 flex items-center gap-2';
        d.innerHTML=`
          <input type="radio" name="color-pair" value="${a},${b}" id="${id}" class="hidden peer">
          <label for="${id}" class="w-full flex items-center justify-center gap-2 p-2 rounded-lg border-2 border-gray-600 cursor-pointer peer-checked:border-teal-500 peer-checked:bg-teal-900/50">
            <span class="w-4 h-4 rounded-full" style="background-color:var(--${a})"></span>
            <span class="w-4 h-4 rounded-full" style="background-color:var(--${b})"></span>
          </label>`;
        selDiv.appendChild(d);
      });
      this.invertPanel.classList.remove('hidden');
    }
    hideInvertPanel(){ this.invertPanel.classList.add('hidden'); }
    showReportPanel(idx,args){
      this.reportPanel.classList.remove('hidden');
      document.getElementById('report-text').textContent = 
        `你发现 Invert(${args.root},${args.a},${args.b}) 被轨迹 #${idx} 影响。`;
      Game.reportContext={idx,args};
    }
    hideReportPanel(){ this.reportPanel.classList.add('hidden'); }
    showModal(t, b){ this.modalTitle.textContent=t; this.modalBody.textContent=b; this.modal.classList.remove('hidden'); }
    hideModal(){ this.modal.classList.add('hidden'); }
    onZoom(e){
      e.preventDefault();
      const s = e.deltaY<0?0.9:1.1;
      const pt = this.getSVGPoint(e.clientX,e.clientY);
      this.vb.x = (this.vb.x-pt.x)*s+pt.x;
      this.vb.y = (this.vb.y-pt.y)*s+pt.y;
      this.vb.w *= s; this.vb.h *= s;
      this.svg.setAttribute('viewBox',`${this.vb.x} ${this.vb.y} ${this.vb.w} ${this.vb.h}`);
    }
    onPointerDown(e){
      if(e.target!==this.svg) return;
      this.isPanning=true;
      this.startPt=this.getSVGPoint(e.clientX,e.clientY);
      this.svg.style.cursor='grabbing';
    }
    onPointerUp(e){
      this.isPanning=false;
      this.svg.style.cursor='grab';
    }
    onPointerMove(e){
      if(!this.isPanning) return;
      e.preventDefault();
      const pt=this.getSVGPoint(e.clientX,e.clientY);
      this.vb.x -= (pt.x-this.startPt.x);
      this.vb.y -= (pt.y-this.startPt.y);
      this.svg.setAttribute('viewBox',`${this.vb.x} ${this.vb.y} ${this.vb.w} ${this.vb.h}`);
    }
    getSVGPoint(x,y){
      const pt=this.svg.createSVGPoint();
      pt.x=x; pt.y=y;
      return pt.matrixTransform(this.svg.getScreenCTM().inverse());
    }
  }

  // --- M8 Game ---
  const Game = {
    state:null, traceManager:null, inductionStack:[], selectedVertex:null, currentLevelId:null, reportContext:null,
    init(){
      LevelManager.init();
      this.traceManager=new TraceManager();
      this.inductionStack=[];
      this.uiManager=new UIManager();
      this.uiManager.init();
      this.loadLevel('L0');
    },
    loadLevel(id){
      this.currentLevelId=id;
      this.state=LevelManager.getInitialState(id);
      this.traceManager=new TraceManager();
      this.inductionStack=[];
      this.selectedVertex=null;
      UI.hideInvertPanel();
      UI.hideReportPanel();
      UI.hideModal();
      UI.render(this.state);
      UI.infoText.textContent = LevelManager.levels[id].name;
      document.querySelectorAll('#level-selector button').forEach(b=>{
        b.classList.toggle('bg-purple-600',b.textContent===id);
        b.classList.toggle('bg-gray-700',b.textContent!==id);
      });
    },
    selectVertex(v){
      this.selectedVertex = (this.selectedVertex===v?null:v);
      UI.render(this.state);
    },
    handleOperator(op,args={}){
      if(op==='Undo'){
        const prev=this.traceManager.undo();
        if(prev){ this.state=prev; UI.render(this.state); }
        return;
      }
      if(op==='SubmitReport'){
        const rpt={op:'SubmitReport',args:this.reportContext};
        this.traceManager.addStep(rpt,this.state,this.state);
        UI.render(this.state);
        GoalChecker.check(this.currentLevelId,this.state,this.traceManager.trace);
        return;
      }
      const oldS=this.state; let newS, operator;
      const v=this.selectedVertex;
      switch(op){
        case 'Assign':
          if(v===null){ UI.infoText.textContent='错误: 请选择顶点'; return; }
          operator=new AssignOp(v,args.color);
          newS = operator.execute(oldS.clone());
          if(!Predicates.isProper(newS)){ UI.infoText.textContent='错误: 非法着色'; return; }
          break;
        case 'Cut':
          if(v===null){ UI.infoText.textContent='错误: 请选择顶点'; return; }
          operator=new CutOp(v);
          newS = operator.execute(oldS);
          break;
        case 'Return':
          if(!this.inductionStack.length){ UI.infoText.textContent='无可返还'; return; }
          operator=new ReturnOp();
          newS = operator.execute(oldS);
          break;
        case 'Invert':
          if(v===null){ UI.infoText.textContent='错误: 请选择顶点'; return; }
          operator=new InvertOp(v,args.a,args.b);
          for(let i=this.traceManager.trace.length-1;i>=0;i--){
            const prev=this.traceManager.trace[i];
            if(prev.op!=='Invert') continue;
            const prevOp=new InvertOp(...Object.values(prev.args));
            const preState=this.findStateByHash(prev.pre_hash);
            if(preState && Kempe.checkDependency(preState,prevOp,operator)){
              this.traceManager.addAttempt(operator,i);
              UI.render(this.state);
              UI.showReportPanel(i,operator.args);
              return;
            }
          }
          newS = operator.execute(oldS);
          break;
        default: return;
      }
      this.state=newS;
      this.traceManager.addStep(operator,oldS,this.state);
      UI.render(this.state);
      GoalChecker.check(this.currentLevelId,this.state,this.traceManager.trace);
      this.selectVertex(null);
    },
    findStateByHash(hash){
      let s=LevelManager.getInitialState(this.currentLevelId);
      if(s.hash===hash) return s;
      for(const step of this.traceManager.trace){
        if(step.pre_hash===hash) return s.clone();
        const C={Assign:AssignOp,Cut:CutOp,Return:ReturnOp,Invert:InvertOp}[step.op];
        if(C&&step.legal){ s=new C(...Object.values(step.args)).execute(s); }
        if(s.hash===hash) return s;
      }
      return null;
    }
  };

  window.onload = ()=>Game.init();
  </script>
</body>
</html>
