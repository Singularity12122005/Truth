<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>4-Colour Theorem â€“ Proof Game</title>
  <style>
    body{margin:0;display:flex;font-family:sans-serif;height:100vh;overflow:hidden;background:#1a1a1a}
    #left{flex:1;background:#f8f9fa;display:flex;flex-direction:column;border-right:2px solid #333}
    #right{width:320px;background:#222;color:#eee;padding:12px;overflow:auto}
    #canvas{flex:1;cursor:pointer;background:#fff;margin:4px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
    .controls{padding:8px;background:#e9ecef;border-top:1px solid #ddd}
    button{margin:3px;padding:8px 12px;font-size:13px;border:none;border-radius:4px;cursor:pointer;background:#007bff;color:white;transition:all 0.2s}
    button:hover{background:#0056b3;transform:translateY(-1px)}
    button:disabled{background:#6c757d;cursor:not-allowed;transform:none}
    .color-keys{display:inline-flex;gap:4px;margin-right:12px}
    .color-key{width:30px;height:30px;border-radius:50%;border:2px solid #333;cursor:pointer;transition:transform 0.2s}
    .color-key:hover{transform:scale(1.1)}
    .log{font-size:11px;white-space:pre-wrap;line-height:1.4;font-family:monospace}
    .success{color:#4CAF50;font-weight:bold}
    .error{color:#F44336;font-weight:bold}
    .info{color:#2196F3}
    .warning{color:#FF9800}
    #levelTitle{margin:0 0 8px 0;color:#4CAF50;font-size:16px}
    #meta{font-size:12px;color:#ccc;margin-bottom:12px;line-height:1.3}
    .status{background:#333;padding:6px;border-radius:4px;margin:4px 0;font-size:11px}
    .selected{box-shadow:0 0 0 3px #007bff}
  </style>
</head>
<body>
  <div id="left">
    <canvas id="canvas"></canvas>
    <div class="controls">
      <div class="color-keys">
        <div class="color-key" data-color="0" style="background:#FFD700" title="é»„è‰² (1)"></div>
        <div class="color-key" data-color="1" style="background:#0077FF" title="è“è‰² (2)"></div>
        <div class="color-key" data-color="2" style="background:#FF3B30" title="çº¢è‰² (3)"></div>
        <div class="color-key" data-color="3" style="background:#34C759" title="ç»¿è‰² (4)"></div>
      </div>
      <button id="btnCut">Cut åˆ‡é™¤</button>
      <button id="btnReturn">Return æ¢å¤</button>
      <button id="btnInvert">Invert åè½¬</button>
      <button id="btnReset">Reset é‡ç½®</button>
      <button id="btnNext">Next Level â–¶</button>
    </div>
  </div>
  <div id="right">
    <h3 id="levelTitle">åŠ è½½ä¸­...</h3>
    <div id="meta"></div>
    <div class="status">
      <div>Selected: <span id="selectedVertex">None</span></div>
      <div>Stack Size: <span id="stackSize">0</span></div>
      <div>Proper: <span id="properStatus">âœ“</span></div>
    </div>
    <hr style="border-color:#444">
    <div id="log" class="log"></div>
  </div>

  <script type="module">
    // =============== ENGINE: GRAPH ===============
    class Vertex {
      constructor(id, x, y) { 
        this.id = id; 
        this.x = x; 
        this.y = y; 
      }
    }

    class Edge {
      constructor(u, v) { 
        this.u = u; 
        this.v = v; 
      }
      equals(e) { 
        return (this.u === e.u && this.v === e.v) || (this.u === e.v && this.v === e.u); 
      }
    }

    class Graph {
      constructor() {
        this.V = new Map();      // id -> Vertex
        this.E = [];             // Edge[]
        this.Pi = new Map();     // id -> adjacency list (clockwise)
      }

      addVertex(id, x, y) {
        if (this.V.has(id)) throw new Error('duplicate vertex');
        this.V.set(id, new Vertex(id, x, y));
        this.Pi.set(id, []);
      }

      addEdge(u, v) {
        const e = new Edge(u, v);
        if (this.E.some(edge => edge.equals(e))) return; // skip duplicates
        this.E.push(e);
        this.Pi.get(u).push(v);
        this.Pi.get(v).push(u);
      }

      neighbors(id) { return this.Pi.get(id) || []; }
      degree(id)    { return this.neighbors(id).length; }
    }

    // =============== ENGINE: STATE ===============
    const COLORS = ['#FFD700', '#0077FF', '#FF3B30', '#34C759']; // é»„/è“/çº¢/ç»¿

    class StackFrame {
      constructor(v, adj, pos, colour) {
        this.v = v; 
        this.adj = [...adj]; 
        this.pos = pos; 
        this.colour = colour;
      }
    }

    class State {
      constructor(graph) {
        this.G = graph;                  // Graph
        this.Phi = new Map();            // id -> colour index (0-3) | null (âŠ¥)
        this.G.V.forEach((_v, id) => this.Phi.set(id, null));
        this.K = [];                     // Stack<StackFrame>
      }

      clone() {
        const g = this.G; // Graph å¯¹è±¡ä¸ºåŒå¼•ç”¨å³å¯ï¼ˆä¸åœ¨ clone ä¸­æ”¹å›¾ç»“æ„ï¼‰
        const s = new State(g);
        s.Phi = new Map(this.Phi);
        s.K = this.K.map(f => structuredClone(f));
        return s;
      }

      // -------- Predicate --------
      isProper() {
        for (const e of this.G.E) {
          const cu = this.Phi.get(e.u), cv = this.Phi.get(e.v);
          if (cu !== null && cu === cv) return false;
        }
        return true;
      }

      isWin() {
        return this.isProper() && [...this.Phi.values()].every(c => c !== null);
      }
    }

    // =============== ENGINE: OPERATORS ===============
    function assignColour(state, vId, colourIdx) {
      const s = state.clone();
      if (s.Phi.get(vId) !== null) return [null, 'Vertex already coloured'];
      s.Phi.set(vId, colourIdx);
      if (!s.isProper()) return [null, 'Improper colouring'];
      return [s, null];
    }

    function cut(state, vId) {
      const s = state.clone();
      if (!s.G.V.has(vId)) return [null, 'Vertex not in graph'];
      const adj = s.G.neighbors(vId);
      const pos = 0; // ç®€åŒ–ï¼šä¸è®°å½•åµŒå…¥ç›¸å¯¹ä½ç½®
      const frame = new StackFrame(vId, adj, pos, s.Phi.get(vId));
      s.K.push(frame);

      // çœŸæ­£æŠŠé¡¶ç‚¹ç§»é™¤
      s.G.V.delete(vId);
      s.G.E = s.G.E.filter(e => e.u !== vId && e.v !== vId);
      s.Phi.delete(vId);
      s.G.Pi.delete(vId);
      for (const n of adj) {
        s.G.Pi.set(n, s.G.Pi.get(n).filter(x => x !== vId));
      }
      return [s, null];
    }

    function ret(state) {
      const s = state.clone();
      if (!s.K.length) return [null, 'Stack empty'];
      const frame = s.K.pop();
      const {v, adj, colour} = frame;
      
      // å¤æ´»é¡¶ç‚¹ - æ‰¾ä¸€ä¸ªåˆé€‚çš„ä½ç½®
      let x = 250, y = 150;
      if (adj.length > 0) {
        const neighbors = adj.filter(n => s.G.V.has(n));
        if (neighbors.length > 0) {
          const avgX = neighbors.reduce((sum, n) => sum + s.G.V.get(n).x, 0) / neighbors.length;
          const avgY = neighbors.reduce((sum, n) => sum + s.G.V.get(n).y, 0) / neighbors.length;
          x = avgX + (Math.random() - 0.5) * 50;
          y = avgY + (Math.random() - 0.5) * 50;
        }
      }
      
      s.G.addVertex(v, x, y);
      for (const n of adj) {
        if (s.G.V.has(n)) {
          s.G.addEdge(v, n);
        }
      }
      s.Phi.set(v, null); // uncoloured
      return [s, null];
    }

    // Kempe chain (BFS over {a,b} colours through adjacency)
    function kempeChain(state, vId, a, b) {
      const queue = [vId];
      const visited = new Set([vId]);
      while (queue.length) {
        const cur = queue.shift();
        for (const n of state.G.neighbors(cur)) {
          const c = state.Phi.get(n);
          if (!visited.has(n) && (c === a || c === b)) {
            visited.add(n);
            queue.push(n);
          }
        }
      }
      return visited;
    }

    function invert(state, vId, aIdx, bIdx) {
      const s = state.clone();
      const cRoot = s.Phi.get(vId);
      if (cRoot === null) return [null, 'Root uncoloured'];
      if (aIdx === bIdx) return [null, 'Need two distinct colours'];
      const chain = kempeChain(s, vId, aIdx, bIdx);
      chain.forEach(id => {
        const c = s.Phi.get(id);
        if (c === aIdx) s.Phi.set(id, bIdx);
        else if (c === bIdx) s.Phi.set(id, aIdx);
      });
      if (!s.isProper()) return [null, 'Invert caused improper colouring'];
      return [s, null];
    }

    // =============== ENGINE: LEVEL ===============
    class Level {
      constructor(name, desc, buildFn, goalPredicate) {
        this.name = name;
        this.desc = desc;
        this.buildFn = buildFn; // () => State
        this.goalPredicate = goalPredicate; // (State, Trace[]) => bool
      }
    }

    const Trace = [];
    function pushTrace(txt) { 
      Trace.push(txt); 
      log(`> ${txt}`, 'info');
    }
    function clearTrace() { 
      Trace.length = 0; 
    }

    // =============== LEVELS ===============
    const levels = [];

    // L0: åŸºç¡€ä¸‰è§’å½¢ç€è‰²
    levels.push(new Level('L0: Warm-up Triangle',
      'ç›®æ ‡ï¼šç»™ä¸‰è§’å½¢çš„3ä¸ªé¡¶ç‚¹åˆæ³•ä¸Šè‰²ï¼ˆç›¸é‚»é¡¶ç‚¹é¢œè‰²ä¸åŒï¼‰ã€‚\nè¿™æ˜¯æœ€åŸºç¡€çš„å›¾ç€è‰²é—®é¢˜ã€‚',
      function buildState() {
        const g = new Graph();
        g.addVertex('A', 200, 100);
        g.addVertex('B', 350, 200);
        g.addVertex('C', 200, 300);
        g.addEdge('A', 'B');
        g.addEdge('B', 'C');
        g.addEdge('C', 'A');
        return new State(g);
      },
      function goal(s) { return s.isWin(); }
    ));

    // L1: Cut/Return å½’çº³
    levels.push(new Level('L1: Induction â€“ Cut & Return',
      'ç›®æ ‡ï¼šä½¿ç”¨Cutå’ŒReturnæ“ä½œå®Œæˆç€è‰²ã€‚\nè¿™æ¼”ç¤ºäº†å½’çº³è¯æ˜çš„æ ¸å¿ƒæ€æƒ³ï¼šå…ˆç®€åŒ–é—®é¢˜ï¼Œå†æ„å»ºè§£ã€‚',
      function buildState() {
        const g = new Graph();
        // äº”è¾¹å½¢ + ä¸­å¿ƒç‚¹ï¼ˆè½®å›¾W5ï¼‰
        g.addVertex('X', 250, 150);
        const coords = [[200, 80, 'A'], [350, 120, 'B'], [380, 220, 'C'], [250, 280, 'D'], [120, 220, 'E']];
        coords.forEach(([x, y, id]) => g.addVertex(id, x, y));
        
        // å¤–ç¯
        for (let i = 0; i < 5; i++) {
          g.addEdge(coords[i][2], coords[(i + 1) % 5][2]);
        }
        // ä¸­å¿ƒåˆ°æ‰€æœ‰å¤–å›´
        coords.forEach(([,, id]) => g.addEdge('X', id));
        return new State(g);
      },
      function goal(s, trace) {
        return s.isWin() && trace.some(t => t.includes('Cut')) && trace.some(t => t.includes('Return'));
      }
    ));

    // L2: Kempe é“¾
    levels.push(new Level('L2: Kempe Chain Magic',
      'æŒ‘æˆ˜ï¼šä¸­å¿ƒé¡¶ç‚¹Xè¢«4ä¸ªä¸åŒé¢œè‰²åŒ…å›´ï¼Œæ— æ³•ç›´æ¥ç€è‰²ã€‚\nä½¿ç”¨Kempeé“¾åè½¬æ“ä½œæ¥åˆ›é€ ç€è‰²ç©ºé—´ï¼',
      function buildState() {
        const g = new Graph();
        g.addVertex('X', 250, 150);
        const ring = [['A', 200, 80, 0], ['B', 350, 120, 1], ['C', 300, 250, 2], ['D', 150, 250, 3]];
        ring.forEach(([id, x, y]) => g.addVertex(id, x, y));
        
        // æ–¹å½¢ç¯
        ring.forEach((_, i) => g.addEdge(ring[i][0], ring[(i + 1) % 4][0]));
        ring.forEach(([id]) => g.addEdge('X', id));
        
        const s = new State(g);
        ring.forEach(([id,,, colour]) => s.Phi.set(id, colour));
        return s;
      },
      function goal(s) { return s.isWin(); }
    ));

    // L3: å¤æ‚Kempeæƒ…å†µ
    levels.push(new Level('L3: Complex Kempe Scenario',
      'é«˜çº§æŒ‘æˆ˜ï¼šå¤šä¸ªå†²çªéœ€è¦å·§å¦™çš„Kempeé“¾æ“ä½œåºåˆ—ã€‚\nè¿™æ¨¡æ‹Ÿäº†Appel-Hakenè¯æ˜ä¸­çš„å¤æ‚æƒ…å†µã€‚',
      function buildState() {
        const g = new Graph();
        // åˆ›å»ºä¸€ä¸ªæ›´å¤æ‚çš„é…ç½®
        const vertices = [
          ['A', 150, 100, 0], ['B', 250, 100, 1], ['C', 350, 100, 2],
          ['D', 350, 200, 3], ['E', 250, 200, null], ['F', 150, 200, 0],
          ['X', 250, 150, null], ['Y', 200, 150, null]
        ];
        
        vertices.forEach(([id, x, y]) => g.addVertex(id, x, y));
        
        const edges = [
          ['A','B'], ['B','C'], ['C','D'], ['D','E'], ['E','F'], ['F','A'],
          ['A','X'], ['B','X'], ['C','Y'], ['D','Y'], ['E','X'], ['E','Y'], ['F','X']
        ];
        
        edges.forEach(([u, v]) => g.addEdge(u, v));
        
        const s = new State(g);
        vertices.forEach(([id,,, color]) => {
          if (color !== null) s.Phi.set(id, color);
        });
        
        return s;
      },
      function goal(s) { return s.isWin(); }
    ));

    // =============== UI & RENDERER ===============
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    let currentIdx = 0, level, state, originalState;
    let selectedVertex = null, pendingInvertA = null;

    function load(idx) {
      level = levels[idx];
      state = level.buildFn();
      originalState = level.buildFn(); // ä¿å­˜åŸå§‹çŠ¶æ€ç”¨äºé‡ç½®
      currentIdx = idx;
      selectedVertex = null;
      pendingInvertA = null;
      clearTrace();
      
      document.getElementById('levelTitle').textContent = level.name;
      document.getElementById('meta').textContent = level.desc;
      document.getElementById('log').textContent = '';
      document.getElementById('selectedVertex').textContent = 'None';
      
      updateStatus();
      draw();
      log(`å…³å¡åŠ è½½: ${level.name}`, 'success');
    }

    function log(msg, cls = '') { 
      const div = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      div.innerHTML += `<div class="${cls}">[${time}] ${msg}</div>`;
      div.scrollTop = div.scrollHeight;
    }

    function updateStatus() {
      document.getElementById('stackSize').textContent = state.K.length;
      document.getElementById('properStatus').textContent = state.isProper() ? 'âœ“' : 'âœ—';
      document.getElementById('properStatus').style.color = state.isProper() ? '#4CAF50' : '#F44336';
    }

    function hitTest(x, y) {
      for (const v of state.G.V.values()) {
        const dx = x - v.x, dy = y - v.y;
        if (dx * dx + dy * dy < 400) return v.id; // 20px radius
      }
      return null;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç»˜åˆ¶è¾¹
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#333';
      state.G.E.forEach(e => {
        const u = state.G.V.get(e.u), v = state.G.V.get(e.v);
        ctx.beginPath();
        ctx.moveTo(u.x, u.y);
        ctx.lineTo(v.x, v.y);
        ctx.stroke();
      });
      
      // ç»˜åˆ¶é¡¶ç‚¹
      state.G.V.forEach(v => {
        const cIdx = state.Phi.get(v.id);
        
        // é¡¶ç‚¹åœ†
        ctx.fillStyle = cIdx === null ? '#e9ecef' : COLORS[cIdx];
        ctx.beginPath();
        ctx.arc(v.x, v.y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // è¾¹æ¡†
        ctx.strokeStyle = selectedVertex === v.id ? '#007bff' : '#333';
        ctx.lineWidth = selectedVertex === v.id ? 3 : 2;
        ctx.stroke();
        
        // æ ‡ç­¾
        ctx.fillStyle = '#000';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(v.id, v.x, v.y);
      });
      
      updateStatus();
    }

    function checkWin() {
      if (level.goalPredicate(state, Trace)) {
        log('ğŸ‰ å…³å¡å®Œæˆï¼æ­å–œï¼', 'success');
        document.getElementById('btnNext').style.background = '#28a745';
        setTimeout(() => {
          document.getElementById('btnNext').style.background = '#007bff';
        }, 2000);
      }
    }

    // =============== EVENT HANDLERS ===============
    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const id = hitTest(e.clientX - rect.left, e.clientY - rect.top);
      if (id) {
        selectedVertex = id;
        document.getElementById('selectedVertex').textContent = id;
        log(`é€‰ä¸­é¡¶ç‚¹: ${id}`);
        draw();
      }
    });

    // é¢œè‰²æŒ‰é’®ç‚¹å‡»
    document.querySelectorAll('.color-key').forEach(key => {
      key.addEventListener('click', () => {
        if (!selectedVertex) {
          log('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡¶ç‚¹', 'warning');
          return;
        }
        
        const colour = parseInt(key.dataset.color);
        const [newState, err] = assignColour(state, selectedVertex, colour);
        if (err) {
          log(`âŒ ${err}`, 'error');
        } else {
          state = newState;
          pushTrace(`Assign ${selectedVertex} color-${colour}`);
          draw();
          checkWin();
        }
      });
    });

    // é”®ç›˜äº‹ä»¶
    window.addEventListener('keydown', e => {
      const key = e.key;
      if ('1234'.includes(key) && selectedVertex) {
        const colour = Number(key) - 1;
        const [newState, err] = assignColour(state, selectedVertex, colour);
        if (err) {
          log(`âŒ ${err}`, 'error');
        } else {
          state = newState;
          pushTrace(`Assign ${selectedVertex} color-${colour}`);
          draw();
          checkWin();
        }
      }
    });

    // æŒ‰é’®äº‹ä»¶
    document.getElementById('btnCut').onclick = () => {
      if (!selectedVertex) {
        log('è¯·å…ˆé€‰æ‹©è¦åˆ‡é™¤çš„é¡¶ç‚¹', 'warning');
        return;
      }
      const [newState, err] = cut(state, selectedVertex);
      if (err) {
        log(`âŒ ${err}`, 'error');
      } else {
        state = newState;
        pushTrace(`Cut ${selectedVertex}`);
        selectedVertex = null;
        document.getElementById('selectedVertex').textContent = 'None';
        draw();
      }
    };

    document.getElementById('btnReturn').onclick = () => {
      const [newState, err] = ret(state);
      if (err) {
        log(`âŒ ${err}`, 'error');
      } else {
        state = newState;
        pushTrace('Return');
        draw();
        checkWin();
      }
    };

    document.getElementById('btnInvert').onclick = () => {
      if (!selectedVertex) {
        log('è¯·å…ˆé€‰æ‹©æ ¹é¡¶ç‚¹è¿›è¡ŒKempeé“¾åè½¬', 'warning');
        return;
      }
      
      const a = parseInt(prompt('è¾“å…¥é¢œè‰² a (1-4):')) - 1;
      const b = parseInt(prompt('è¾“å…¥é¢œè‰² b (1-4):')) - 1;
      
      if (isNaN(a) || isNaN(b) || a < 0 || a > 3 || b < 0 || b > 3) {
        log('âŒ æ— æ•ˆçš„é¢œè‰²è¾“å…¥', 'error');
        return;
      }
      
      const [newState, err] = invert(state, selectedVertex, a, b);
      if (err) {
        log(`âŒ ${err}`, 'error');
      } else {
        state = newState;
        pushTrace(`Invert ${selectedVertex} colors ${a}<->${b}`);
        draw();
        checkWin();
      }
    };

    document.getElementById('btnReset').onclick = () => {
      state = level.buildFn();
      selectedVertex = null;
      document.getElementById('selectedVertex').textContent = 'None';
      clearTrace();
      log('å…³å¡é‡ç½®', 'info');
      draw();
    };

    document.getElementById('btnNext').onclick = () => {
      load((currentIdx + 1) % levels.length);
    };

    // åˆå§‹åŒ–
    window.addEventListener('load', () => {
      setTimeout(() => load(0), 100);
    });
  </script>
</body>
</html>
